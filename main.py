
# TODO - Add UAC Elevation / Admin Check


import os
import traceback
import sys
import argparse
import logging
import datetime
import csv

import configuration_data
import configs.files.start
import configs.services.start
import configs.tasks.start
import configs.false_extensions.start
import configs.network_connections.start
import configs.startup.start
import configs.prefetch.start
import configs.hash_scan.start
import configs.evtx.security.start
import configs.evtx.powershell_operational.start
import configs.powershell.start
import configs.process.start

import helpers.ip_updater
import helpers.update_loki



def parse_args():
    arguments = {}
    parser = argparse.ArgumentParser(usage='''
    ### QuickScan ###
    Rapidly Triage Windows Hosts for Suspicious Activity and Artifacts.
    

    Usage Examples:
    quickscan.exe 
    
    quickscan.exe -c prefetch,network_connections,services,startup
    
    ''')
    parser.add_argument("-c", "--configs", help="Which Configurations to Run - if left blank, will run all.",
                        required=False, nargs=1, type=str)
    args = parser.parse_args()

    available_configs = os.listdir('configs')

    if args.configs:
        try:
            config_list = args.configs[0].split(',')
        except:
            configs = args.configs[0]
            config_list[0] = configs
        for c in config_list:
            if c not in available_configs:
                print(f"Error: Could not find config - {c}")
                sys.exit(1)
            else:
                pass
        arguments['configs'] = config_list
    else:
        arguments['configs'] = available_configs
    print(f"Using Configs: {arguments['configs']}")

    return arguments


def launch_configs(args):
    """
    Launch relevant configuration based on what is contained in input arguments.
    :param args:
    :return:
    """
    if 'files' in args['configs']:
        configs.files.start.launch()
    if 'services' in args['configs']:
        configs.services.start.launch()
    if 'tasks' in args['configs']:
        configs.tasks.start.launch()
    if 'false_extensions' in args['configs']:
        configs.false_extensions.start.launch()
    if 'network_connections' in args['configs']:
        configs.network_connections.start.launch()
    if 'startup' in args['configs']:
        configs.startup.start.launch()
    if 'prefetch' in args['configs']:
        configs.prefetch.start.launch()
    #if 'hash_scan' in args['configs']:
    #    configs.hash_scan.start.launch()
    if 'evtx' in args['configs']:
        configs.evtx.security.start.launch()
        configs.evtx.powershell_operational.start.launch()
    if 'powershell' in args['configs']:
        configs.powershell.start.launch()
    if 'process' in args['configs']:
        configs.process.start.launch()


def start_detections(file, fields):
    """
    Start the CSV containing 'detections' generated by QuickScan
    :param file:
    :param fields:
    :return:
    """
    with open(file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=fields)
        writer.writeheader()

def build_ips():
    # TODO - Add More Threat Feeds / Improve Fidelity
    # Primarily sourced from http://www.covert.io/threat-intelligence/
    """
    Provide a dictionary with file_name reference and URL to ip_updater.launch()
     - typically a line-delimited text-based source for malicious IP addresses.
    :return:
    """
    url_list = {}
    url_list['greensnow'] = 'http://blocklist.greensnow.co/greensnow.txt'
    url_list['ci_badguys'] = 'http://cinsscore.com/list/ci-badguys.txt'
    url_list['the_haleys_ssh'] = 'http://charles.the-haleys.org/ssh_dico_attack_hdeny_format.php/hostsdeny.txt'
    url_list['mirai_scanner'] = 'http://data.netlab.360.com/feeds/mirai-scanner/scanner.list'
    url_list['dshield_top10'] = 'https://feeds.dshield.org/top10-2.txt'
    url_list['blocklist_de'] = 'http://lists.blocklist.de/lists/all.txt'
    url_list['malcode'] = 'http://malc0de.com/bl/IP_Blacklist.txt'
    url_list['rutgers'] = 'http://report.rutgers.edu/DROP/attackers'
    url_list['emergingthreats_ciarmy'] = 'http://rules.emergingthreats.net/blockrules/emerging-ciarmy.rules'
    url_list['emergingthreats_compromised'] = 'http://rules.emergingthreats.net/blockrules/emerging-compromised.rules'
    url_list['emergingthreats_fwrules'] = 'http://rules.emergingthreats.net/fwrules/emerging-PF-CC.rules'
    url_list['emergingthreats_bots'] = 'http://rules.emergingthreats.net/open/suricata/rules/botcc.rules'
    url_list['emergingthreats_compromised2'] = 'http://rules.emergingthreats.net/open/suricata/rules/compromised-ips.txt'
    url_list['sblam_blacklist'] = 'https://sblam.com/blacklist.txt'
    url_list['tor_exits'] = 'https://raw.githubusercontent.com/SecOps-Institute/Tor-IP-Addresses/master/tor-exit-nodes.lst'
    url_list['tor_nodes'] = 'https://raw.githubusercontent.com/SecOps-Institute/Tor-IP-Addresses/master/tor-nodes.lst'
    url_list['binary_defense'] = 'https://www.binarydefense.com/banlist.txt'
    url_list['maxmind_highrisk'] = 'https://www.maxmind.com/en/high-risk-ip-sample-list'
    url_list['myip_blacklist'] = 'https://myip.ms/files/blacklist/htaccess/latest_blacklist.txt'
    url_list['firehol_proxies'] = 'https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/proxyspy_1d.ipset'
    url_list['scriptzteam_badips'] = 'https://raw.githubusercontent.com/scriptzteam/badIPS/main/ips.txt'
    url_list['talos_intel'] = 'https://www.talosintelligence.com/documents/ip-blacklist'
    url_list['torproject'] = 'https://check.torproject.org/cgi-bin/TorBulkExitList.py?ip=1.1.1.1'
    url_list['urlhaus_urls'] = 'https://urlhaus.abuse.ch/downloads/text/'
    url_list['loki_signatures'] = 'https://raw.githubusercontent.com/Neo23x0/signature-base/master/iocs/c2-iocs.txt'
    helpers.ip_updater.launch(url_list)


def build_hashset():
    """
    Update malicious hashes from high-fidelity sources.
    :return:
    """
    if not os.path.isfile('iocs\\loki_hashlist.txt'):
        print("Updating Hash Set from Loki Signature Repository...")
        helpers.update_loki.launch()

def main():

    logo = '''
   ___       _    _    ___               
  / _ \ _  _(_)__| |__/ __| __ __ _ _ _  
 | (_) | || | / _| / /\__ \/ _/ _` | ' \ 
  \__\_\\_,_|_\__|_\_\|___/\__\__,_|_||_|                           
    '''
    logo2 = '''
░██████╗░██╗░░░██╗██╗░█████╗░██╗░░██╗░██████╗░█████╗░░█████╗░███╗░░██╗
██╔═══██╗██║░░░██║██║██╔══██╗██║░██╔╝██╔════╝██╔══██╗██╔══██╗████╗░██║
██║██╗██║██║░░░██║██║██║░░╚═╝█████═╝░╚█████╗░██║░░╚═╝███████║██╔██╗██║
╚██████╔╝██║░░░██║██║██║░░██╗██╔═██╗░░╚═══██╗██║░░██╗██╔══██║██║╚████║
░╚═██╔═╝░╚██████╔╝██║╚█████╔╝██║░╚██╗██████╔╝╚█████╔╝██║░░██║██║░╚███║
░░░╚═╝░░░░╚═════╝░╚═╝░╚════╝░╚═╝░░╚═╝╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝░░╚══╝
'''
    print(logo2)
    print("https://github.com/joeavanzato/QuickScan")
    print("Run As Administrator!") #TODO - Check Admin - PyUAC works for elevation or other
    args = parse_args()
    log_file = "quickscan_log.log"
    logging.basicConfig(filename=log_file, level=logging.DEBUG)
    logging.info(str(datetime.datetime.now()) + " New Logger Initialized")
    try:
        os.mkdir('evidence')
    except OSError as e:
        pass
    configuration_data.fields = ['Name', 'Reason','File Path','Registry Path','MITRE Tactic','MITRE Technique','Risk','Details']
    configuration_data.detection_csv = 'detection_output.csv'
    start_detections(configuration_data.detection_csv, configuration_data.fields)
    build_hashset()
    build_ips()
    launch_configs(args)


main()